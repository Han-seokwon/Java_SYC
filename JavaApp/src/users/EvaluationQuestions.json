{
  "count": 10,
  "items": [
    {
      "question": "QuickSort 알고리즘의 최악의 경우 시간 복잡도는 무엇인가요?",
      "choiceList": ["O(1)", "O(n)", "O(log n)", "O(n^2)", "O(n log n)"],
      "answerNum": 4,
      "point": 5
    },
    {
      "question": "어떤 자료 구조가 후입선출 (LIFO) 원리를 따르나요?",
      "choiceList": ["Queue", "Stack", "Linked List", "Tree", "Array"],
      "answerNum": 2,
      "point": 3
    },
    {
      "question": "알고리즘이 입력 크기에 관계없이 상수 실행 시간을 갖는다면 시간 복잡도는 무엇인가요?",
      "choiceList": ["O(1)", "O(n)", "O(log n)", "O(n^2)", "O(log log n)"],
      "answerNum": 1,
      "point": 2
    },
    {
      "question": "이진 검색에서 입력 데이터의 주된 특징은 무엇인가요?",
      "choiceList": ["데이터는 정렬되어야 한다.", "데이터는 정렬되지 않아야 한다.", "데이터는 역순으로 정렬되어야 한다.", "데이터는 무작위로 정렬되어야 한다.", "데이터는 알파벳 순으로 정렬되어야 한다."],
      "answerNum": 1,
      "point": 1
    },
    {
      "question": "다음 중 어떤 것이 정렬 알고리즘의 종류가 아닌가요?",
      "choiceList": ["QuickSort", "MergeSort", "Breadth-First Search", "BubbleSort", "InsertionSort"],
      "answerNum": 3,
      "point": 1
    },
    {
      "question": "자료 구조에서 해시 함수의 목적은 무엇인가요?",
      "choiceList": ["랜덤한 숫자 생성", "데이터 암호화", "소수 생성", "데이터를 고정 크기 배열에 매핑", "데이터 압축"],
      "answerNum": 4,
      "point": 2
    },
    {
      "question": "탐색, 삽입 및 삭제에 O(log n) 시간이 걸리는 자료 구조는 무엇인가요?",
      "choiceList": ["Array", "Linked List", "Hash Table", "Binary Search Tree", "Stack"],
      "answerNum": 4,
      "point": 1
    },
    {
      "question": "배열 대비 연결 리스트의 주된 이점은 무엇인가요?",
      "choiceList": ["원소에 대한 상수 시간 접근", "동적 크기", "캐시 지역성", "원소의 순차 저장", "임의 접근에 효율적"],
      "answerNum": 2,
      "point": 2
    },
    {
      "question": "알고리즘의 맥락에서 '재귀'는 무엇을 의미하나요?",
      "choiceList": ["일련의 명령을 반복하는 루프", "자기 자신을 호출하는 함수", "원소를 역순으로 정렬", "데이터를 해시로 변환", "배열에서 원소를 찾는 것"],
      "answerNum": 2,
      "point": 1
    },
    {
      "question": "다음 중 탐욕 알고리즘의 예시는 무엇인가요?",
      "choiceList": ["Depth-First Search", "Dijkstra의 알고리즘", "벨만-포드 알고리즘", "크루스칼의 알고리즘", "BubbleSort"],
      "answerNum": 4,
      "point": 2
    }
  ]
}
